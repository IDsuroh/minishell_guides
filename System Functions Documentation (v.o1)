# System Functions Documentation (v.o1)

## Table of Contents
1. [Introduction](#introduction)
2. [Standard I/O Library (`stdio.h`)](#stdioh)
   - `printf`
3. [Standard Library (`stdlib.h`)](#stdlibh)
   - `malloc`, `free`, `exit`, `getenv`
4. [Readline Functions (`readline/readline.h`, `readline/history.h`)](#readline)
   - `readline`, `rl_clear_history`, `rl_on_new_line`, `rl_replace_line`, `rl_redisplay`, `add_history`
5. [Signals (`signal.h`)](#signalh)
   - `signal`, `sigaction`, `sigemptyset`, `sigaddset`, `kill`
6. [Process and File Control (`unistd.h`, `sys/types.h`, `sys/wait.h`, `fcntl.h`, `sys/stat.h`)](#process-file-control)
   - `fork`, `wait`, `waitpid`, `wait3`, `wait4`, `execve`
   - `write`, `access`, `open`, `read`, `close`
   - `getcwd`, `chdir`, `stat`, `lstat`, `fstat`, `unlink`
   - `dup`, `dup2`, `pipe`
7. [Directory Functions (`dirent.h`)](#direnth)
   - `opendir`, `readdir`, `closedir`
8. [Terminal & Device Functions (`unistd.h`, `sys/ioctl.h`, `termios.h`, termcap/curses)](#terminal-device-functions)
   - `isatty`, `ttyname`, `ttyslot`, `ioctl`
   - `tcsetattr`, `tcgetattr`
   - `tgetent`, `tgetflag`, `tgetnum`, `tgetstr`, `tgoto`, `tputs`
9. [Error Handling (`errno.h` and related)](#error-handling)
   - `strerror`, `perror`
10. [Conclusion](#conclusion)

---

<a name="introduction"></a>
## 1. Introduction

This documentation (v.o1) describes system-level functions in C, grouped by the libraries or headers they originate from. Each section begins with a high-level overview of the library's purpose and relevant concepts, then explains each function with **proper usage** examples and **improper usage** pitfalls. The goal is to provide enough detail about the *why* and *how* behind these functions.

---
<a name="stdioh"></a>
## 2. Standard I/O Library (`stdio.h`)

### Overview
The `stdio.h` library provides functions for:
- Reading from standard input (stdin)
- Writing to standard output (stdout)
- Formatted printing (e.g., `printf`)

### `printf`
**Header**: `#include <stdio.h>`

**Description**: Prints formatted output to `stdout`.

**Proper Usage**:
```c
#include <stdio.h>

int main(void) {
    printf("Hello, %s!\n", "World");
    return 0;
}
```
- **Reason**: Must use correct format specifiers (`%d` for int, `%s` for string, etc.).

**Improper Usage**:
```c
printf("Number: " 10); // Missing format specifier
```
- **Issue**: Compiler interprets incorrectly, can cause errors or unexpected behavior.

**Similar Functions**:
- `fprintf` (prints to a file `FILE*`)
- `sprintf` (prints to a string buffer)

---
<a name="stdlibh"></a>
## 3. Standard Library (`stdlib.h`)

### Overview
These functions deal with:
- Dynamic memory management
- Process exit
- Environment variables

### `malloc`
**Description**: Dynamically allocates the requested amount of memory.

**Proper Usage**:
```c
#include <stdlib.h>

int *arr = malloc(10 * sizeof(int));
if (!arr) {
    perror("Allocation failed");
    exit(EXIT_FAILURE);
}
```
- **Reason**: Always check for `NULL` return to avoid segmentation faults.

**Improper Usage**:
```c
int *arr = malloc(10); // Not enough bytes for 10 ints
```
- **Issue**: Likely causes out-of-bounds writes.

### `free`
**Description**: Frees a block of memory previously allocated by `malloc`, `calloc`, or `realloc`.

**Proper Usage**:
```c
free(arr);
```
- **Reason**: Prevents memory leaks.

**Improper Usage**:
```c
free(arr);
free(arr); // Double-free, undefined behavior
```

### `exit`
**Description**: Terminates the current process immediately, returning a status code to the operating system.

**Proper Usage**:
```c
exit(EXIT_SUCCESS);
```

### `getenv`
**Description**: Fetches the value of an environment variable.

**Proper Usage**:
```c
char *path = getenv("PATH");
if (path) {
    printf("PATH is: %s\n", path);
}
```
- **Reason**: Check for `NULL` if the variable is not set.

---
<a name="readline"></a>
## 4. Readline Functions (`readline/readline.h`, `readline/history.h`)

### Overview
Readline provides advanced command-line editing and history features. It’s not part of the standard C library, but widely used in interactive shells.

- Maintains an internal buffer and allows user to edit typed text, recall commands, etc.

### `readline`
**Description**: Reads a line from stdin, optionally displaying a prompt.

**Proper Usage**:
```c
#include <readline/readline.h>
#include <readline/history.h>

int main() {
    char *input = readline("myshell> ");
    if (input) {
        // process input
    }
}
```
- **Reason**: The prompt is a helpful user interface.

### `rl_clear_history`
**Description**: Clears the current history list.

**Usage**:
```c
rl_clear_history();
```
- Typically used at program shutdown.

### `rl_on_new_line`
**Description**: Signals readline that the cursor is on a new line.

### `rl_replace_line`
**Description**: Replaces the content of the current line in the editing buffer.

### `rl_redisplay`
**Description**: Forces readline to redisplay the current input buffer (e.g., after signals).

### `add_history`
**Description**: Adds a line to the in-memory history.

**Proper Usage**:
```c
char *line = readline("myshell> ");
add_history(line);
```

---
<a name="signalh"></a>
## 5. Signals (`signal.h`)

### Overview
**What are signals?**  
Signals are software interrupts sent to a process to indicate events such as:
- **SIGINT** (Ctrl+C)
- **SIGTERM** (termination request)
- **SIGSEGV** (segmentation fault)
- etc.

When a signal arrives, the OS interrupts normal program flow and either:
- Executes a **signal handler** (if defined), or
- Performs a default action (often termination).

### `signal`
**Description**: Sets a simple handler for a specific signal.

**Proper Usage**:
```c
#include <signal.h>
#include <stdio.h>

void handler(int signum) {
    printf("Caught signal %d\n", signum);
}

int main() {
    signal(SIGINT, handler);
    while (1) { /* ... */ }
}
```
- **Issue**: Some signals like `SIGKILL` cannot be caught.

### `sigaction`
**Description**: More robust method to set handlers with additional flags.

**Proper Usage**:
```c
struct sigaction sa;
sigemptyset(&sa.sa_mask);
sa.sa_handler = handler;
sa.sa_flags = 0;
sigaction(SIGINT, &sa, NULL);
```

### `sigemptyset`, `sigaddset`
**Description**: Utilities to build **signal sets**.

```c
sigset_t set;
sigemptyset(&set);
sigaddset(&set, SIGTERM);
```

### `kill`
**Description**: Sends a signal to a process (by PID).

**Usage**:
```c
kill(pid, SIGTERM);
```

---
<a name="process-file-control"></a>
## 6. Process and File Control

These functions are primarily declared in `unistd.h`, `sys/wait.h`, `fcntl.h`, and `sys/stat.h`. They handle process creation/management, file descriptors, and more.

### **Processes**

**What is a Child Process?**  
When `fork()` is called, the current process (parent) is duplicated. The new process (child) inherits many attributes but has its own PID.

#### `fork`
**Description**: Creates a new process.

```c
pid_t pid = fork();
if (pid == 0) {
    // child
} else if (pid > 0) {
    // parent
} else {
    perror("fork failed");
}
```

#### `wait`, `waitpid`
**Description**: The parent waits for a child process to finish, avoiding zombie processes.

#### `wait3`, `wait4`
**Description**: Like `wait`, but also returns **resource usage** in a `struct rusage`.

**What is resource usage?**  
Includes CPU time (user/system), memory usage, etc., letting you see how much system resources the child consumed.

#### `execve`
**Description**: Replaces the current process image with a new program.

**Usage**:
```c
char *argv[] = {"/bin/ls", "-l", NULL};
execve("/bin/ls", argv, envp);
perror("execve failed");
exit(1);
```

#### `exit`
**Description**: Immediately terminates the calling process with an exit status.

### **File & Directory I/O**

#### `write`, `access`, `open`, `read`, `close`
- **`write(fd, buf, count)`**: Writes data from `buf` to `fd`.
- **`access(path, mode)`**: Checks if the process can read/write/execute at `path`.
- **`open(path, flags, mode)`**: Opens a file, returning a descriptor.
- **`read(fd, buf, count)`**: Reads data into `buf`.
- **`close(fd)`**: Closes the descriptor.

#### `getcwd`, `chdir`
**What is the current working directory?**  
It’s the base directory from which relative paths are resolved.
- **`getcwd(buf, size)`**: Puts the **absolute path** of the current directory into `buf`.
- **`chdir(path)`**: Changes the current directory to `path`.

#### `stat`, `lstat`, `fstat`
**Meaning of "Retrieves file info by path"**: Gains information such as size, permissions, timestamps, etc.

- `stat(path, &info)`: Follows symlinks.
- `lstat(path, &info)`: Doesn’t follow symlinks.
- `fstat(fd, &info)`: Gets info via an open descriptor.

**What are symbolic links?**  
A file that points to another file/directory path.  
**What are filesystem links?**  
Hard links or symlinks that let multiple references point to the same data.

#### `unlink`
**Description**: Removes a filesystem link to a file (often effectively deleting the file if no other links exist).

### **Descriptor Duplication**

#### `dup`, `dup2`
- **`dup(fd)`**: Returns a new descriptor that refers to the same file.
- **`dup2(old_fd, new_fd)`**: Forces duplication into `new_fd`.

**How are `dup` and `dup2` different?**  
- `dup` picks the **lowest available** descriptor.
- `dup2` specifically *targets* `new_fd`, closing it if open.

#### `pipe`
**Description**: Creates a unidirectional data channel (pipe) with two descriptors: read end and write end.

---
<a name="direnth"></a>
## 7. Directory Functions (`dirent.h`)

### Overview
Provides ways to open and read directory contents as a **directory stream**.

**What is a directory stream?**  
An abstraction that sequentially reads directory entries.

### `opendir`, `readdir`, `closedir`
- **`opendir(path)`**: Opens a directory stream for `path`.
- **`readdir(dirp)`**: Returns the **next entry** (`struct dirent`) in that directory stream.  
  *What is the "next entry"?*  
  Each call to `readdir` yields one file/subdirectory name in the directory.
- **`closedir(dirp)`**: Closes the stream.

---
<a name="terminal-device-functions"></a>
## 8. Terminal & Device Functions

### Overview
Covers terminal checks, advanced I/O control, and terminal capability references.

**What is a terminal device?**  
Originally a physical device (monitor + keyboard). Today, typically a pseudo-terminal in a shell emulator. Terminal devices handle special input processing (like echoing typed chars, handling signals on Ctrl+C, etc.).

### `isatty`, `ttyname`, `ttyslot`, `ioctl`
- **`isatty(fd)`**: Returns non-zero if `fd` is a terminal.
- **`ttyname(fd)`**: Returns the name (e.g. `/dev/pts/0`) of the terminal.
- **`ttyslot()`**: Gets the slot number of the terminal for historical multi-tty contexts.
- **`ioctl(fd, request, ...)`**: Performs device-specific control.

### `tcsetattr`, `tcgetattr`
- **Description**: Set/get terminal attributes in raw or cooked mode, echo on/off, etc.

**Proper Usage**:
```c
#include <termios.h>

struct termios oldt, newt;
tcgetattr(STDIN_FILENO, &oldt);
newt = oldt;
newt.c_lflag &= ~(ICANON | ECHO);
tcsetattr(STDIN_FILENO, TCSANOW, &newt);
```

### `tgetent`, `tgetflag`, `tgetnum`, `tgetstr`, `tgoto`, `tputs`
- **Termcap** or *termcap* based function calls.
- **What is termcap?**  
  A database describing capabilities of different terminals. This helps programs to do things like "move cursor to X,Y" in a portable manner.
- **Numeric capability**: e.g., number of columns (`co`), lines (`li`).
- **String capability**: e.g., escape sequences to clear screen (`cl`), move cursor (`cm`).

**Usage**:
```c
#include <curses.h>

char buf[2048];
tgetent(buf, getenv("TERM"));
int cols = tgetnum("co"); // numeric capability
char *clear_str = tgetstr("cl", NULL); // string capability
if (clear_str)
    tputs(clear_str, 1, putchar);
```

---
<a name="error-handling"></a>
## 9. Error Handling (`errno.h`, `string.h`, etc.)

### `strerror`, `perror`
- **`strerror(errno)`**: Returns a descriptive string for the current error code.
- **`perror(message)`**: Prints `message`, then the error string for `errno`.

**Proper Usage**:
```c
FILE *fp = fopen("nonexistent.txt", "r");
if (!fp) {
    perror("fopen failed");
}
```

---
<a name="conclusion"></a>
## 10. Conclusion

This document (v.o1) details a broad set of system functions and relevant concepts:
- **Signals** (software interrupts)
- **Processes** (`fork`, `execve`, `wait*`)
- **File I/O** (`open`, `read`, `write`, `close`, etc.)
- **Directory streams** (`opendir`, `readdir`, `closedir`)
- **Terminal control** (`isatty`, `tcsetattr`, termcap)
- **Error handling** (`perror`, `strerror`)

Understanding these fundamentals is crucial for writing robust, low-level C applications—like shells—that interact directly with the operating system. Always practice **defensive programming** with thorough error-checking and awareness of how each function might fail.

